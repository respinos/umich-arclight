# frozen_string_literal: true

require 'arclight'
require 'benchmark'
require 'json'
require 'fileutils'
require 'nokogiri'

Deprecation.default_deprecation_behavior = :silence

module UmArclight
  module Package
    class Generator

      COMPONENT_FIELDS = [
        'id',
        'parent_ssi',
        'parent_ssim',
        'ref_ssi',
        'ref_ssm',
        'component_level_isim',
        'normalized_title_ssm',
        'level_ssm',
        'scopecontent_teism',
        'unitid_ssm',
        'odd_tesim',
        'bioghist_tesim',
        'total_digital_object_count_isim',
        'digital_objects_ssm',
        'containers_ssim',
        'repository_ssm',
      ]

      attr_accessor :identifier, :doc, :fragment, :collection,  :session, :index
      
      def initialize(identifier:)
        @identifier = identifier
        @collection = nil
        @session = ActionDispatch::Integration::Session.new(Rails.application)
        @session.host = 'findingaids.lib.umich.edu'
        @session.https!(true)
        @index = Index.new()
      end

      def build_html

        response = get("/catalog/#{identifier}")
        @doc = Nokogiri::HTML5(response.body)

        components = []
        elapsed_time = Benchmark.realtime do
          @collection = fetch_doc(identifier)
          components = fetch_components(identifier)
        end
        puts "UM-Arclight generate package : #{collection.id} : fetch components (in #{elapsed_time.round(3)} secs)."      

        elapsed_time = Benchmark.realtime do
          @fragment = render_fragment({
            repository: collection.repository_config,
            collection: collection,
            components: components
          })

          update_navigation_links()
          update_package_html()
        end
        puts "UM-Arclight generate package : #{collection.id} : build HTML (in #{elapsed_time.round(3)} secs)."      

        output_filename = generate_output_filename('.html')
        unless Dir.exists?(File.dirname(output_filename))
          FileUtils.makedirs(File.dirname(output_filename))
        end

        File.open(output_filename, "w") do |f|
          f.puts doc.serialize
        end
      end

      def build_pdf

        # build the source in tmp
        FileUtils.mkdir_p(working_path_name)
        Dir.chdir(working_path_name)
        FileUtils.mkdir_p('assets')

        elapsed_time = Benchmark.realtime do
          update_package_html_pdf()
          update_package_styles_pdf()
          update_package_scripts_pdf()
          # set the media
          doc.root['data-media'] = 'print'
        end
        puts "UM-Arclight generate package: #{collection.id} : update HTML for PDF (in #{elapsed_time.round(3)} secs)."      

        local_html_filename = "#{collection.id}.local.html"
        File.open(local_html_filename, "w") do |f|
          f.puts doc.serialize
        end

        output_filename = File.join(Rails.root, generate_output_filename('.pdf'))
        FileUtils.mkdir_p(File.dirname(output_filename))

        elapsed_time = Benchmark.realtime do
          Puppeteer.launch(headless: true, args: [ '--no-sandbox', '--disable-setuid-sandbox' ]) do |browser|
            page = browser.new_page
            page.goto("file:#{working_path_name}/#{identifier}.local.html", wait_until: 'networkidle2')
            page.pdf(
              path: output_filename,
              print_background: true,
              omit_background: false,
              display_header_footer: false,
              timeout: 300000,
              footer_template: '<div style="font-weight: bold">Generated by findingaids.lib.umich.edu</div>',
              margin: {
                top: 50,
                right: 70,
                bottom: 70,
                left: 70
              },
            )
          end
        end

        File.unlink(local_html_filename)

        puts "UM-Arclight generate package: #{collection.id} : puppeteer render (in #{elapsed_time.round(3)} secs)."      
      end

      private

      def self.configure_repository
        Blacklight.repository_class.new(CatalogController.new.helpers.blacklight_config)
      end

      def generate_output_filename(ext)
        "#{DulArclight.finding_aid_data}/pdf/#{collection.repository_id}/#{collection.id}#{ext}"
      end

      def working_path_name
        "#{Rails.root}/tmp/pdf"
      end

      def get(url)
        session.get("/catalog/#{identifier}")
        session.response
      end

      def fetch_doc(id)
        params = {
          fl: '*',
          q: [ "id:#{id}"],
          start: 0,
          rows: 1
        }
        response = index.search(params)
        response.documents.first
      end

      def fetch_components(id)
        params = {
          fl: COMPONENT_FIELDS.join(','),
          q: [ "ead_ssi:#{id}"],
          start: 0,
          rows: 1000
        }
        components = []
        response = index.search(params)
        total = response.total
        start = 0
        while ( response.documents.present? )
          puts "-- harvesting: #{start} / #{total}"
          response.documents.each do |doc|
            if doc.id == id
              # ignore the collection doc
              next
            end
            components << doc
          end
          start += 1000
          params[:start] = start
          response = index.search(params)
        end
        components
      end

      def render_fragment(variables)
        paths = ActionView::PathSet.new(["app/views"])
        lookup_context = ActionView::LookupContext.new(paths)
        renderer = ActionView::Renderer.new(lookup_context)
        view_context = ActionView::Base.new(renderer)
        view_context.assign(variables)
        view_context.extend Arclight::EadFormatHelpers

        fragment_html = renderer.render(view_context, template: 'arclight/fragments/fragment')
        Nokogiri::HTML5(fragment_html)
      end

      def update_navigation_links
        doc.css('#about-collection-nav a').each do |link|
          href = link['href']
          link['href'] = '#' + href.split('#').last
        end
      end

      def update_package_html
        style_el = doc.xpath('/html/head/link[@rel="stylesheet"]').last
        style_el.add_next_sibling(fragment.css('#utility-styles').first)
        doc.css('#summary dl').first << fragment.css('dl#ead_author_block dt,dd')
        doc.css('#background').first << fragment.css('#revdesc_changes')
        doc.css('div.al-contents').first.replace(fragment.css('div.al-contents-ish').first)
        doc.css('body').first << fragment.css('script').first
        doc.css('.card-img').first.remove
        doc.css('#navigate-collection-toggle').first.remove
        doc.css('#context-tree-nav .tab-pane.active').first.inner_html = '<div id="toc"><ul></ul></div>';
      end

      def update_package_html_pdf
        doc.css('.access-preview-snippet').first.inner_html = '<div id="toc"><ul></ul></div>'
        doc.css('m-website-header').first.replace(fragment.css('header').first)
        doc.css('footer').first.remove
        doc.css('div.x-printable').remove
      end

      def update_package_styles_pdf
        doc.xpath('/html/head/link').each do |link|
          if link['rel'] == 'stylesheet' && link['href'].start_with?('/assets/')
            session.get(link['href'])
            stylesheet = session.response.body

            # now we have to look for url(/assets) here
            buffer = stylesheet.split(/\n/)
            buffer.each_with_index do |line, i|
              if matches = line.scan(/url\(\/assets\/([^\)]+)\)/)
                matches.each do |match|
                  asset_path = match[0]
                  filename = asset_path.split(/[\?#]/).first

                  return if File.exists?("assets/#{filename}")

                  session.get("/assets/#{asset_path}")
                  resource = session.response.body


                  unless Dir.exists?(File.dirname("assets/#{filename}"))
                    FileUtils.makedirs("assets/#{File.dirname(filename)}")
                  end

                  File.open("./assets/#{filename}", "wb") do |f|
                    f.puts resource
                  end
                  content_type = session.response.content_type
                  line.gsub!("/assets/#{asset_path}", "./assets/#{filename}")
                end
                buffer[i] = line
              end
            end

            filename = link['href'].split(/[\?#]/).first

            unless Dir.exists?(".#{File.dirname(filename)}")
              FileUtils.makedirs(".#{File.dirname(filename)}")
            end

            File.open(".#{filename}", "wb") do |f|
              f.puts stylesheet
            end
            link['href'] = ".#{filename}"
          end
        end
      end

      def update_package_scripts_pdf
        # remove the script tags
        doc.xpath('/html/head/script').each do |script|
          script.remove
        end
      end
    end

    class Queue
      def initialize
        @index = Index.new
      end

      def setup(repository_ssm: nil)
        identifiers = fetch_collection_identifiers(repository_ssm)
        identifiers.each do |identifier|
          STDERR.puts "-- queueing #{identifier}"
          ::PackageFindingAidJob.perform_later(identifier)
        end
      end

      def fetch_collection_identifiers(repository_ssm)
        params = {
          fl: 'id',
          q: [ "level_ssm:collection"],
          start: 0,
          rows: 1000
        }
        if repository_ssm
          params['fq'] = [ "repository_ssm:\"#{repository_ssm}\"" ]
        end
        identifiers = []
        response = index.search(params)
        total = response.total
        start = 0
        while ( response.documents.present? )
          response.documents.each do |doc|
            identifiers << doc.id
          end
          start += 1000
          params[:start] = start
          response = index.search(params)
        end
        identifiers
      end
    end

    class Index
      attr_accessor :index
      def initialize
        @index = Blacklight.repository_class.new(CatalogController.new.helpers.blacklight_config)
      end

      def search(params)
        @index.search(params)
      end
    end
  end
end